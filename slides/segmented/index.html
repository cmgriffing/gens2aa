<!doctype html>
<html lang="en">

    <head>
        <meta charset="utf-8">

        <title>Generators, Async/Await, and Koa.js</title>

        <meta name="description" content="Taming promise chains and easy migrations for the future.">
        <meta name="author" content="Chris Griffing">

        <meta name="apple-mobile-web-app-capable" content="yes">
        <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

        <link rel="stylesheet" href="css/reveal.css">
        <link rel="stylesheet" href="css/theme/night.css" id="theme">

        <!-- Code syntax highlighting -->
        <link rel="stylesheet" href="lib/css/zenburn.css">

        <!-- Printing and PDF exports -->
        <script>
            var link = document.createElement( 'link' );
            link.rel = 'stylesheet';
            link.type = 'text/css';
            link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
            document.getElementsByTagName( 'head' )[0].appendChild( link );
        </script>

        <style>

            pre.half {
                width: 49%;
                display: inline-block;
                vertical-align: top;
            }

        </style>

        <!--[if lt IE 9]>
        <script src="lib/js/html5shiv.js"></script>
        <![endif]-->
    </head>

    <body>

        <div class="reveal">

            <!-- Any section element inside of this container is displayed as a slide -->
            <div class="slides">
                
                <section>
                    <h1>Generators, Async/Await, and Koa.js</h1>
                    <h3>Taming promise chains and easy migrations for the future</h3>
                    <p>
                        <small>by <a href="http://chrisgriffing.com">Chris Griffing</a></small>
                    </p>
                    <aside class="notes">
                        Im here today to talk about Generators and Async/Await, and how Koa gives you an easy migration path for using these new Javascript features.
                    </aside>
                </section>

                <section>

                    <section>
                        
                        <h2>Callback Hell</h2>
                        <pre><code>
Widgets.createWidgets(20, function(widgets) {
  Gadgets.createGadgetsFromWidgets(widgets, function(gadgets) {
    Things.createThingsFromGadgets(gadgets, function(things) {
      res.set('Content-Type', 'application/json')
      res.send(JSON.stringify(things))
    })
  })
})
                        </code></pre>
                        <p>This isn't the messiest example, but if you add in error checking it gets really ugly because you have to handle errors at every level of the chain.</p>
                        <aside class="notes">
                            You can flatten this out by using named functions or function expressions.
                        </aside>

                    </section>

                    <section>
                        <h2>A Little Better</h2>
                        <pre><code>
var thingsCallback = function(things) {
    res.set('Content-Type', 'application/json')
    res.send(JSON.stringify(things))
}
var gadgetsCallback = function(gadgets) {
    Things.createThingsFromGadgets(gadgets, thingsCallback)
}
//res is available the wrapping Express endpoint
var widgetsCallback = function(widgets) {
    Gadgets.createGadgetsFromWidgets(widgets, gadgetsCallback)
}
Widgets.createWidgets(20, widgetsCallback)
                        </code></pre>
                        <p>Pretty verbose</p>
                        <aside class="notes">
                            Maybe named and hoisted functions would have been better, but still not great.
                        </aside>
                    </section>

                </section>

                <section>
                    <h2>Long Promise Chains</h2>
                    <pre><code>
Widgets.createWidgets(20)
  .then(function (widgets) {
    return Gadgets.createGadgetsFromWidgets(widgets)
  }).then(function (gadgets) {
    return Things.createThingsFromGadgets(gadgets)
  }).then(function (things) {
    res.set('Content-Type', 'application/json')
    res.send(JSON.stringify(things))
  }).catch(function(error) {
    //handle errors
  })
                    </code></pre>
                    <p>A bit messy but much better than nested callbacks.</p>
                    <aside class="notes">
                        These are the contents of a simple Express endpoint. Here, we use promises to prevent "callback hell". This should be familiar to most developers and it really is much better than nested callbacks. It also gives us the option of having one `.catch()` call at the end to catch errors from the whole sequence. However, this type of async flow control can be made even cleaner using generators on top of promises.
                    </aside>
                </section>

                <section>
                    <h2>Generators: Quick Example</h2>
                    <pre><code>
async(function * (next) {
  try {
    let widgets = yield Widgets.createWidgets(20)
    let gadgets = yield Gadgets.createGadgetsFromWidgets(widgets)
    let things = yield Things.createThingsFromGadgets(gadgets)
    return things
  } catch (e) {
    //handle errors
  }
})
                    </code></pre>
                    <p>This lets us yield each promise in a synchronous fashion without blocking the thread from executing other code.</p>
                    <aside class="notes">
                        As a quick example, here is what the code might look like using a specialized wrapper for generators.
                    </aside>
                </section>
                
                <section>
                    <h2>Generators: Basics</h2>
                    <pre class="half"><code>
function * evenNumbers() {
  for(var i = 1; true; i++) {
    if(i % 2 === 0) {
      yield i
    }
  }
}
                    </code></pre>
                    <pre class="half"><code>
> x = evenNumbers()
  evenNumbers {[[GeneratorStatus]]: "suspended", [[GeneratorReceiver]]: Window}
> x.next()
  Object {value: 2, done: false}
> x.next()
  Object {value: 4, done: false}
> x.next()
  Object {value: 6, done: false}
> x.next()
  Object {value: 8, done: false}
> x.next()
  Object {value: 10, done: false}
                    </code></pre>
                    <script>
                        function * evenNumbers() {
                            for(var i = 1; true; i++) {
                                if(i % 2 === 0) {
                                    yield i
                                }
                            }
                        }
                    </script>
                    <aside class="notes">
                        So, first we must become familiar with generators at their most basic level. Here, we see a generator in its natural environment. They are very good at dealing with sequences of data or events. If you look closely, you see that we have an unbounded for loop, which ends up not being an issue because of how the generator handles the flow.
                    </aside>
                </section>
                
                <section>
                    <h2>Generators (stoppable)</h2>
                    <pre class="half">Definition:<code>
function * evenNumbersStoppable() {
  for(var i = 1; true; i++) {
    if(i % 2 === 0) {
      var stop = yield i
      if(stop === true) {
        return i
      }
    }
  }
}
                    </code></pre>
                    <pre class="half">Output:<code>
> y = evenNumbersStoppable()
  evenNumbersStoppable {[[GeneratorStatus]]: "suspended", [[GeneratorReceiver]]: Window}
> y.next()
  Object {value: 2, done: false}
> y.next()
  Object {value: 4, done: false}
> y.next()
  Object {value: 6, done: false}
> y.next()
  Object {value: 8, done: false}
> y.next(true)
  Object {value: 8, done: true}
> y.next()
  Object {value: undefined, done: true}
> y.next()
  Object {value: undefined, done: true}
                    </code></pre>
                    <p>To stop a generator, return a value instead of yielding it.</p>
                    <script>
                        function * evenNumbersStoppable() {
                            for(var i = 1; true; i++) {
                                if(i % 2 === 0) {
                                    var stop = yield i
                                    if(stop === true) {
                                        return i
                                    }
                                }
                            }
                        }
                    </script>
                    <aside class="notes">
                        Now we see how a generator can be stopped. An important thing to look at is the "done" parameter. This can be very useful when debugging.
                    </aside>
                </section>

                <section>
                    <h2>Generators (throwing)</h2>
                    <pre class=""><code>
> x = evenNumbersStoppable()
  evenNumbersStoppable {[[GeneratorStatus]]: "suspended", [[GeneratorReceiver]]: Window}
> x.next()
  Object {value: 2, done: false}
> x.next()
  Object {value: 4, done: false}
> x.throw(new Error('Something has gone terribly wrong here'))
  Uncaught Error: Something has gone terribly wrong here(â€¦)(anonymous function) @ VM6460:2InjectedScript._evaluateOn @ (program):878InjectedScript._evaluateAndWrap @ (program):811InjectedScript.evaluate @ (program):667
> x.next()
  Object {value: undefined, done: true}
                    </code></pre>
                    <p>Generators have a built in function for throwing errors and stopping itself.</p>
                    <aside class="notes">
                        This function stops the generator and properly throws an error afterwards which makes try/catch the proper pattern for handling errors.
                    </aside>
                </section>

                <section>
                    <h2>Generators (wrapping promises)</h2>
                    <pre><code>
function async(makeGenerator){
  return function () {
    var generator = makeGenerator.apply(this, arguments)

    function handle(result){
      // result => { done: [Boolean], value: [Object] }
      if (result.done) return Promise.resolve(result.value)

      return Promise.resolve(result.value).then(function (res){
        return handle(generator.next(res))
      }, function (err){
        return handle(generator.throw(err))
      });
    }

    try {
      return handle(generator.next())
    } catch (ex) {
      return Promise.reject(ex)
    }
  }
}
                    </code></pre>
                    <p>This wrapper allows us to yield the result of a promise or handle the error of it with a try/catch.</p>
                    <aside class="notes">
                        When we put it all together, we can create a function like this to wrap and yield the result of promises.
                    </aside>
                </section>

                <section>
                    <h2>Generators (wrapping promises): examples</h2>
                    <pre>A Sequence of Operations:<code>
var get = async(function *(){
  var left = yield readJSON('left.json')
  var right = yield readJSON('right.json')
  return {left: left, right: right}
})
                    </code></pre>
                    <pre>Parallel Operations:<code>
var get = async(function *(){
  var left = readJSON('left.json')
  var right = readJSON('right.json')
  return {left: yield left, right: yield right}
})
                    </code></pre>
                    <aside class="notes">
                        Using the wrapper function we are able to yield the inner promises. This creates a much cleaner way of handling async tasks. These promises will also throw an error when they reject.
                    </aside>
                </section>

                <section>
                    <h2>Async/Await: examples</h2>
                    <pre>A Sequence of Operations:<code>
var get = async function (){
  var left = await readJSON('left.json')
  var right = await readJSON('right.json')
  return {left: left, right: right}
}
                    </code></pre>
                    <pre>Parallel Operations:<code>
var get = async function (){
  var left = readJSON('left.json')
  var right = readJSON('right.json')
  return {left: await left, right: await right}
}
                    </code></pre>
                    <p>Looking similar? There is a reason.</p>
                    <aside class="notes">
                        The reason async/await looks so similar is that it is actually using generators underneath.
                    </aside>
                </section>
                
                <section>
                    <h2>Async/Await</h2>
                    <ul>
                        <li>Uses wrapped generators for promise-based control flow.</li>
                        <li>Originally slated as a feature for ES2016, but was delayed.</li>
                        <li>Currently at Stage-3 of spec approval. Already supported by Chakra, so only one other vendor needs to support it to get it to Stage-4.</li>
                    </ul>
                    <aside class="notes">
                        Generators are already available in Node. Async/Await is not. You can get the benefits of it by using Babel, but there are people who are uncomfortable running their server code through Babel.
                    </aside>
                </section>

                <section>
                    <h2>What about Koa?</h2>
                    <ul>
                        <li>Originally made by TJ Hollowaychuk</li>
                        <li>Middleware is already wrapped to support easy promise-based generator flows.</li>
                        <li>Koa2 beta is stable, ready, and waiting for async/await support in Node.</li>
                    </ul>
                </section>


                <section>
                    <h2>Migrating: From Express to Koa</h2>
                    <img src="images/diffs/side-by-side/Computed_Diff_-_Diff_Checker-1.png" />
                    <p>Convert a normal middleware function to a generator.</p>
                    <aside class="notes">
                        The generator is still a bit ugly because I wanted to make this an iterative process. The important part is that the promise based logic is still there. We just ported the logic into a Koa endpoint.
                    </aside>
                </section>
                <section>
                    <h2>Migrating: From then to yield</h2>
                    <img src="images/diffs/side-by-side/Computed_Diff_-_Diff_Checker-2.png" />
                    <p>Looking much cleaner.</p>
                    <aside class="notes">
                        Now that we have gotten rid of the "then"s and started yielding all the promises, things are much easier to read.
                    </aside>
                </section>
                <section>
                    <h2>Migrating: From yield to await</h2>
                    <img src="images/diffs/side-by-side/Computed_Diff_-_Diff_Checker-3.png" />
                    <p>So Simple.</p>
                    <aside class="notes">
                        I feel like someone could write a series of regex expressions to automatically do this process. Think of all the glorious internet points.
                    </aside>
                </section>

                <section>
                    <h2>Caveat</h2>
                    <ul>
                        <li>Unable to be optimized by compiler.</li>
                    </ul>
                    <aside class="notes">
                        Generators cannot be optimized by the compiler. However, the underlying promises still can be. So, it is important to make sure that the generators are at the top level.
                    </aside>
                </section>

                <section>
                    <h2>Citations and Further Reading</h2>
                    <ul>
                        <li>
                            Generators - Forbes Lindesay 
                            <a href="https://www.promisejs.org/generators/">https://www.promisejs.org/generators/</a>
                        </li>
                        <li>
                            Async/Await - Eddit Zaneski 
                            <a href="https://www.twilio.com/blog/2015/10/asyncawait-the-hero-javascript-deserved.html">https://www.twilio.com/blog/2015/10/asyncawait-the-hero-javascript-deserved.html</a>
                        </li>
                        <li>
                            ES7 Async/Await - Ross Boucher
                            <a href="http://rossboucher.com/await/#/">http://rossboucher.com/await/#/</a>
                        </li>
                    </ul>
                </section>

            </div>



        </div>

        <script src="lib/js/head.min.js"></script>
        <script src="js/reveal.js"></script>

        <script>

            // Full list of configuration options available at:
            // https://github.com/hakimel/reveal.js#configuration
            Reveal.initialize({
                controls: true,
                progress: true,
                history: true,
                center: true,

                transition: 'slide', // none/fade/slide/convex/concave/zoom

                // Optional reveal.js plugins
                dependencies: [
                    { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
                    { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                    { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                    { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
                    { src: 'plugin/zoom-js/zoom.js', async: true },
                    { src: 'plugin/notes/notes.js', async: true }
                ]
            });

        </script>

    </body>
</html>
